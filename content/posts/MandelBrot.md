---
title: "The Mandelbrot Set: Infinite Complexity from Simple Iteration"
date: 2025-12-07
math: true
description: "Understanding and rendering the most famous object in mathematics using Python and JavaScript"
tags: ["Fractals", "Algorithms", "Complex Analysis", "Visualization"]
---

While Euclidean geometry deals with smooth shapes and integer dimensions, fractal geometry explores rough, self-similar shapes with fractional dimensions. The Mandelbrot set is the "Hello World" of fractal geometry, yet it contains infinite complexity generated by a surprisingly simple recursive rule.



## Definition: The Iterative Function

The Mandelbrot set is defined on the complex plane. It is the set of complex numbers $c$ for which the function $f_c(z) = z^2 + c$ does not diverge when iterated from $z=0$.

Let $c$ be a complex parameter. We define a sequence of complex numbers $(z_n)_{n=0}^{\infty}$ by:

$$z_0 = 0$$
$$z_{n+1} = z_n^2 + c$$

The Mandelbrot set, denoted as $\mathcal{M}$, is defined as:

$$\mathcal{M} = \{ c \in \mathbb{C} : \exists s \in \mathbb{R}, |z_n| \le s \quad \forall n \in \mathbb{N} \}$$

In simpler terms:
- If the magnitude $|z_n|$ stays bounded (small) forever, **$c$ is inside the set** (usually colored black).
- If $|z_n|$ shoots off to infinity, **$c$ is outside the set** (colored based on how fast it escapes).

## The Escape Criterion

To render the set computationally, we cannot iterate forever. We need a stopping condition. Mathematicians proved that if the modulus of $z_n$ ever exceeds 2, the sequence will inevitably escape to infinity.

**Theorem (Escape Radius):** If $|z_n| > 2$ for some $n$, then $|z_k| \to \infty$ as $k \to \infty$.

Thus, our algorithmic check for any pixel (point $c$) becomes:
1. Initialize $z = 0$.
2. Loop up to a maximum number of iterations (e.g., 100).
3. Update $z \leftarrow z^2 + c$.
4. Check if $|z| > 2$.
    - If yes: Break loop. The point is unstable.
    - If loop finishes without breaking: The point is likely in the set.

## Implementation: The Naive vs. Vectorized Approach

As engineering students, we care about efficiency. Calculating this pixel-by-pixel in a nested loop is $O(W \times H \times N)$, where $W, H$ are resolution and $N$ is max iterations.

### 1. Python Implementation (Vectorized with NumPy)

Using Python loops is slow. We can use NumPy broadcasting to compute the entire grid simultaneously.

```python
import numpy as np
import matplotlib.pyplot as plt

def mandelbrot(h, w, max_iter=100):
    """
    Vectorized Mandelbrot set calculation.
    """
    # 1. Create a grid of complex numbers
    y, x = np.ogrid[-1.4:1.4:h*1j, -2.0:0.8:w*1j]
    c = x + y*1j
    z = c
    div_time = max_iter + np.zeros(z.shape, dtype=int)

    # 2. Iterate
    for i in range(max_iter):
        z = z**2 + c
        # Find points that escaped in this iteration
        diverge = z*np.conj(z) > 2**2            
        div_now = diverge & (div_time == max_iter) 
        div_time[div_now] = i                    
        z[diverge] = 2                           

    return div_time

# Visualization
plt.figure(figsize=(10, 10))
plt.imshow(mandelbrot(800, 800), cmap='magma', extent=[-2.0, 0.8, -1.4, 1.4])
plt.title("The Mandelbrot Set")
plt.show()

```


{{< mandelbrot >}}